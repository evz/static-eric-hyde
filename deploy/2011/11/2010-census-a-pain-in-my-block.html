<!doctype html>
<!-- https://github.com/paulirish/html5-boilerplate/blob/master/index.html -->
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--> <html lang="en"> <!--<![endif]-->
<head>
    <meta charset="">
  <meta http-equiv="X-UA-Compatible" content="">
  <title>2010 Census: A pain in my block</title>
  <meta name="description" content="Rendering arbitrary geometries from census blocks">
  <meta name="author" content="Eric van Zanten">
  <meta name="viewport" content="">

    <!-- Place favicon.ico & apple-touch-icon.png
        in the root of your domain and delete these references -->
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    <link rel="stylesheet" href="/media/css/style.css">
  
    <!-- All JavaScript at the bottom, except for Modernizr which
        enables HTML5 elements & feature detects -->
    <script src="/media/js/libs/modernizr-1.7.min.js"></script>
    <!--[if lt IE 9]>
    	<script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
    <![endif]-->
    <script type="text/javascript" src="http://use.typekit.com/zaw2yij.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    </head>
<body id="2010-census-a-pain-in-my-block">
                                                                                      <section id="wrapper" class="content">
          <div id="left-col">
              <header id="header" class="banner clearfix">
              <h1 id="blog-title"><a href="/">Eric van Zanten - Statically</a></h1>
                <h2 class="breadcrumb"><!-- Figure out breadcrumbs--></h2>              </header>
                        <div id="menu">
                <ul>
                    <li class="page_item"><a title="About this site" href="/about-this-site.html">About this site</a></li>
                </ul>
            </div>
                        <div id="sidebar">
                <div id="feed-container">
                    <p><a id="feed_link" href="http://feeds.feedburner.com/static-eric">Subscribe to the RSS Feed</a></p>
                </div>
                <div>
                <form id="searchform">
                    <div>
                        <input type="text" id="s" name="s"><input type="button" value="Search" id="searchsubmit">
                    </div>
                </form>
                </div>
            </div>
          </div>
          <div id="right-col">
              <article class="post">
<h1 class="posttitle">2010 Census: A pain in my block</h1>
<time class="post-author" datetime="2011-11-13">
    Posted: Sun, 13 Nov 2011
</time>
<a href="http://twitter.com/share"
    class="twitter-share-button"
    data-count="horizontal"
    data-via="evanzanten">Tweet</a>
    <script type="text/javascript"
        src="http://platform.twitter.com/widgets.js"></script>
<div class="entry">
<p>I&rsquo;ve written about my very limited exploits in exploring and leveraging 2010 census data in the past but this weekend I finally got back around to doing something about it. What I ended up with is looking like a pretty useful tool for anyone looking at projecting census data onto arbitrary&nbsp;geographies.</p>
<p><strong>A quick&nbsp;recap</strong></p>
<p>For those who didn&rsquo;t read the first <a href="/2011/10/2010-census-leveraging-whats-already-been-done.html">couple</a> <a href="/2011/10/2010-census-getting-setup.html">posts</a> I wrote about the reasoning behind why I&rsquo;m going through all this trouble in the first place, here&rsquo;s the story so&nbsp;far:</p>
<p>I work for the <a href="http://www.bahai.us">Bah&aacute;&rsquo;&iacute; Faith</a>. The administration of Bah&aacute;&rsquo;&iacute; communities across the continental United States is broken down into what we call Bah&aacute;&rsquo;&iacute; Localities. These can sometimes be mapped one-to-one onto an existing geography, such as a municipal boundary or a county but often times are combinations or subdivisions of those areas. Which makes the task of projecting census data onto them somewhat tricky. After I wrote about getting the census.ire.org Django project setup on my local <span class="caps">VM</span>, I got a Twitter shout out from <a href="http://blog.germuska.com">Joe Germuska</a> over at the <a href="http://blog.apps.chicagotribune.com/">Chicago Tribune</a> suggesting that I take a look at trying to build my shapes out of the basic kernel of all census shapes: the block. So, in case the title of this post doesn&rsquo;t give that away, that&rsquo;s what I&nbsp;did.</p>
<p><strong>Re-purposing guts of the <span class="caps">IRE</span>&nbsp;app</strong></p>
<p>Once I got the <a href="https://github.com/ireapps/census">census.ire.org project</a> setup I kinda sat back at said to myself, &ldquo;uh, <span class="caps">OK</span>, now what&hellip;&rdquo;. My first approach was actually to forget about all the juicy goodness in there and try to just get what I needed from the <span class="caps">API</span> that they offer. Problem is, block level data is not available through the <span class="caps">API</span> (which I suppose is understandable given that there are like, 8,000,000 census blocks in the&nbsp;U.S.).</p>
<p>Since no one else had the data, it was starting to look like I would have to build it myself (*gulp*). In reading the docs for the <span class="caps">IRE</span> Django app, the parts that intrigued me the most were the parts that actually fetched census data and loaded it someplace. The someplace, in their case, was a MongoDB database which, at the end of the day, got dumped out and turned into flat <span class="caps">JSONP</span> files which were then uploaded to an S3 bucket so that schmoes like me could access it through the <span class="caps">API</span>. Problem with that, at least for me, was that I needed some way of comparing my arbitrary shapes with the census block shapes. What I needed, in a nutshell, was a <a href="http://postgis.refractions.net/">PostGIS</a> database with both my arbitrary shapes and the census blocks. Luck for me, <a href="/2011/10/mapping-tools-101-a-few-things-ive-picked-up.html">I&rsquo;ve done that before</a>. </p>
<p>So, what it came down to for me was to basically take what they were doing, rip out the MongoDB parts, put in PostGIS parts, and run some spatial lookups. Easy, right? Well, thanks to the work that was already done, yeah. But really, really&nbsp;boring.</p>
<p><strong>Before the boring part, the&nbsp;code</strong></p>
<p><span class="caps">OK</span>, now we&rsquo;ll get into the meaty part where I show you what I did. My basic approach, like the <span class="caps">IRE</span> app, was to write a series of scripts which actually executed the various steps in the process. The real brains of what&rsquo;s going on is directly cribbed from the <span class="caps">IRE</span> app so I&rsquo;d literally be nowhere without them. If you&rsquo;re interested in seeing what they did before going any further, the hub round which everything else revolves is called batch_sf.sh and lives <a href="https://github.com/ireapps/census/tree/master/dataprocessing">here</a>.</p>
<p>The basic steps I came up with were slightly different than the ones that <span class="caps">IRE</span> uses because of a few things: all I wanted was block level data, I needed to know what area on the surface of the Earth the census data related to, and I didn&rsquo;t need to get all the census tables (I cherry picked 14 that seemed to be what I was after). The steps I followed, in order,&nbsp;are:</p>
<ul>
<li>Load the block level geospatial data into a PostGIS&nbsp;database</li>
<li>Fetch the census data, generate the table headers and save it as&nbsp;<span class="caps">CSV</span></li>
<li>Create a cross reference table that facilitates a relation between the <span class="caps">GIS</span> data and the census&nbsp;data</li>
<li>Load the block level census data into already prepared Django models for the 14 tables that I&nbsp;wanted</li>
<li>Finally, make the spatial relations between my arbitrary geographies and census&nbsp;blocks</li>
</ul>
<p>One word of caution before doing any of this stuff: working with block level data takes a huge amount of patience. When I got my batch script working, I ran it against Connecticut and it took 7 hours to complete. And that&rsquo;s one of the small states with only 67,000+ census blocks. Illinois has something like 450,000+ census blocks so the scale here gets pretty astronomical pretty fast. When I get the final wrinkles ironed out, the next phase will probably involve setting this stuff up on a cloud server, just letting it crank and then coming up with a way of serializing the output into something that I can use without ever having to run this stuff again until the 2020&nbsp;census.</p>
<p><strong>Load <span class="caps">GIS</span>&nbsp;data</strong></p>
<p>This was actually remarkably simple thanks to the <a href="https://docs.djangoproject.com/en/1.3/ref/contrib/gis/layermapping/" title="GeoDjango LayerMapping">GeoDjango LayerMapping tool</a>. All it took was getting the data from <a href="http://www2.census.gov/geo/tiger/TIGER2010/TABBLOCK/2010/" title="Block level GIS data">here</a> and stuffing it into a Django model. Here&rsquo;s the model I went&nbsp;with:</p>
<script src="https://gist.github.com/2305477.js?file=models.py"></script>

<p>The <code>locality</code> field is a <code>ForeignKey</code> to the model where I store the Bah&aacute;&rsquo;&iacute; localities (my arbitrary geographies). The <code>xref</code> field is a ForeignKey to a cross reference table that, at least while it&rsquo;s loading, gives us the ability to relate a place on the surface of the earth to the number of people that live there. Other than that, it&rsquo;s pretty much a one-to-one mapping of the <span class="caps">GIS</span> data that you get from the Census Bureau. Here&rsquo;s my LayerMapping&nbsp;script:</p>
<script src="https://gist.github.com/2305477.js?file=LayerMapping.py"></script>

<p>As I mentioned above, this is something that can take an insane amount of time to complete. If you&rsquo;re having trouble getting it to finish the whole job, the LayerMapping tool does support passing a <code>fid_range</code> keyword argument into the <code>.save()</code> method with a tuple containing the indexes of the first and last features you want to load. That gives you a way of resuming should something get frozen or die on you. On a test run, I was able to load all 450,000+ shapes for the state of Illinois into my Ubuntu VMs with relatively limited resources (<span class="caps">512MB</span> <span class="caps">RAM</span> for app server and <span class="caps">1024MB</span> <span class="caps">RAM</span> for db server) on my Intel i5 MacBook Pro. It finished. Eventually. It helps if you don&rsquo;t&nbsp;watch.</p>
<p><strong>Fetching census&nbsp;data</strong></p>
<p>This part is basically grabs the raw data from the Census Bureau, does some basic cleanup and generates the table headers (using <a href="https://github.com/ireapps/census/blob/master/dataprocessing/make_sf_data_2010_headers.py" title="Making 2010 census table headers">this script</a> from <span class="caps">IRE</span>) so that the next step is easier. I pretty much directly ripped this part off from <a href="https://github.com/ireapps/census/blob/master/dataprocessing/fetch_sf_data_2010.sh" title="Fetch 2010 data script">this script</a> from within the <span class="caps">IRE</span> project. Hey, they told me to <a href="http://blog.apps.chicagotribune.com/2011/10/19/steal-this-code-presentation-to-hackshackers-opengovchicago/" title="Steal this code: News Apps Blog">steal it</a>. One thing I want to point out from within that file is the last&nbsp;line:</p>
<p><code>in2csv -e &amp;quot;latin-1&amp;quot; -f fixed -s ${DATAPROCESSING_DIR}/census2010_geo_schema.csv ${STATE_NAME_ABBR}geo2010.sf1 &amp;gt; ${STATE_NAME_ABBR}geo2010.csv</code></p>
<p>This leverages the ever useful <a href="https://github.com/onyxfish/csvkit" title="CSVKit on Github">csvkit</a> to take the <code>census2010_geo_schema.csv</code> file and add it as a header to the info about the actual geographic areas that are part of the raw census data you downloaded in the first part of the script. This becomes kind of the lynchpin when we get to the part where we&rsquo;re loading the census tables into Django&nbsp;models.</p>
<p><strong>Make cross reference&nbsp;table</strong></p>
<p>The Census Bureau provides the census data in what I consider to be relatively cryptic form. I suppose it&rsquo;s all in the interest of making it portable and platform agnostic but for me it was somewhat of a headache to make heads or tails of what was going on there. Again, if it weren&rsquo;t for the work put in on the <span class="caps">IRE</span> project, I would be&nbsp;nowhere.</p>
<p>The first part of the headache was trying to relate the geospatial data that we&rsquo;ve already loaded to the census tables that we&rsquo;re about to load so that when you query a place, you know how many people live there. The way this was accomplished by the <span class="caps">IRE</span> project was by building sort of a throw away cross reference relation that both the data about a place and the census data about that place have in common. Which is trickier than it sounds for reasons that are totally unknown to me. Since MongoDB is a non-relational database, the process that the <span class="caps">IRE</span> project had to go through to make the relation involved making a key that was stored when you loaded the info about a place and then could refer to later when loading the census data about that that place. My approach was to build a table that each geography would have a ForeignKey to and then looking up that geography using that relation when I loaded the census data. It has pretty much the same effect as the <span class="caps">IRE</span> approach only it&rsquo;s relational rather than non-relational. Anyways, here&rsquo;s the code I used to make the cross reference&nbsp;table:</p>
<script src="https://gist.github.com/2305477.js?file=xref.py"></script>

<p>The crux of what&rsquo;s going on here is that it&rsquo;s taking the <code>[state abbrv]geo2010.csv</code> file that you created in step two, going through it row by row, creating a cross reference based upon the <code>FILEID</code>, (which is basically the same for all of these since we&rsquo;re just using the <a href="http://www2.census.gov/census_2010/04-Summary_File_1/" title="Census Data Summary File - raw data">census summary file</a>) the <code>STUSAB</code> (which is a state level identifier) and the <code>LOGRECNO</code> which is basically an index number for the entry in question. We&rsquo;re then associating that with a particular census block based upon it&rsquo;s <code>geoid</code>. That&rsquo;s basically a concatenation of the various <a href="http://en.wikipedia.org/wiki/Federal_Information_Processing_Standard" title="FIPS on Wikipedia"><span class="caps">FIPS</span></a> codes of the areas that contain that block plus the block&nbsp;number.</p>
<p>One thing to note is that this script uses two external modules for some of it&rsquo;s functionality <code>config</code> and <code>utils</code>. In my implementation, these are pretty much straight copies of <a href="https://github.com/ireapps/census/blob/master/dataprocessing/config.py" title="IRE dataprocessing config file">this</a> and <a href="https://github.com/ireapps/census/blob/master/dataprocessing/utils.py" title="IRE dataprocessing utils file">this</a>, respectively. I&rsquo;m not using everything in there since some of it has to do with the MongoDB&nbsp;parts.</p>
<p>The part that makes a huge difference (and took me a fair bit of time to figure out) was to enable the block <code>SUMLEV</code> in the <code>config</code> file (this is what that <code>if row_dict['SUMLEV'] not in config.SUMLEVS</code> bit up there is all about). When you get the code from the <span class="caps">IRE</span> Github repo, it&rsquo;s not turned on by default (which is understandable). To do that, you just need to add it to <code>SUMLEVS</code> list on line 16 of the <code>config</code> file. For good measure, I also turned all the other ones off so I wouldn&rsquo;t be loading data that I wasn&rsquo;t going to be&nbsp;using.</p>
<p><strong>Actually loading the census&nbsp;counts</strong></p>
<p>Now that we&rsquo;ve made it possible to cross reference the census data with the geospatial data, let&rsquo;s load it up. Just so you know what we&rsquo;re working with, the <span class="caps">SF1</span> (Summary File 1) data that we&rsquo;re loading here is broken down into 300+ tables which are divided amongst the 47 files we downloaded in step two. You can see the extensive (and rather nitpicky) nature of what that looks like in the census.ire.org app (<a href="http://census.ire.org/data/1714000.html" title="Chicago census data">here&rsquo;s Chicago</a>). Since I&rsquo;m really only after 14 of these tables, I only built models to house 14 of them. Here&rsquo;s a sample (putting the whole thing here would just be&nbsp;silly):</p>
<script src="https://gist.github.com/2305477.js?file=pop_table.py"></script>

<p>The script used to load data into these is, again, based heavily upon what was already in the <span class="caps">IRE</span> project, just with the MongoDB parts taken out and the Django <span class="caps">ORM</span>/PostgreSQL/PostGIS parts put in. Here&rsquo;s what that looks&nbsp;like:</p>
<script src="https://gist.github.com/2305477.js?file=load_pop.py"></script>

<p>Quick rundown of the action here: we&rsquo;re getting a census table file (one of the 47 created in step 2) as a command line argument, and associating each row with a <code>CensusBlock</code> object based upon that ever handy cross reference table that we created earlier. The <code>utils.parse_table_from_key(k)</code> part is, again, referencing a function from the <code>utils</code> module that uses a regex to parse which census table the row being looked at contains data from based upon the pattern that is present in the row. Since I&rsquo;m only interested in 14 of the tables, I&rsquo;m only actually loading the data that is from those tables (hence the <code>if k not in GET_CENSUS_TABLE.keys():</code> part. After that, it&rsquo;s just passing the geo_id and the table values into the Django model (which is looked up in the <code>GET_CENSUS_TABLE</code> dict) as keyword arguments. By the way, that&rsquo;s my new favorite Python shortcut: <code>o = m(**v)</code>.</p>
<p><strong>The final relation</strong>
The final step here is to relate my arbitrary geographies with the census blocks they contain. I chose to do this by creating a <code>ForeignKey</code> from the <code>CensusBlock</code> object to the <code>Locality</code> object which contains it. I&rsquo;m still tweaking the actual queries that I&rsquo;m going to run in this stage but, for the purposes of a proof of concept, it&rsquo;s pretty solid. Here&rsquo;s my script for this last&nbsp;stage:</p>
<script src="https://gist.github.com/2305477.js?file=rel_xref.py"></script>

<p>I&rsquo;m actually trying to catch the census blocks associated with a particular area in three, ever widening, passes because the first time I tried this, just using the <code>CensusBlock.objects.filter(mpoly__coveredby=loc.mpoly)</code> filter, I ended up with a bunch of <code>CensusBlock</code> objects that weren&rsquo;t associated with any <code>Locality</code> objects. It&rsquo;s still a little messy but, just to show you it can actually be done, here&rsquo;s a screen shot showing a side-by-side comparison of what our Washington, <span class="caps">D.C.</span> <code>Locality</code> boundaries (which in this case correspond precisely with the actual boundaries of Washington, D.C.) look like next to all the census blocks that make it&nbsp;up:</p>
<p><img alt="Screen shot showing Washington D.C. built out of a Baha'i Locality compared to the same area made out of census blocks" src="/media/images/side-by-side-dc-1024x687.jpg" title="side-by-side-dc" /></p>
<p><strong>Wrapping it&nbsp;up</strong></p>
<p>After I had my 5 scripts together, I made another script that basically takes a state name as command line argument and executes all the other scripts in order. It also handles downloading and unpacking the&nbsp;data:</p>
<script src="https://gist.github.com/2305477.js?file=batch_loader.sh"></script>

<p>So, really all you have to do is execute that and wait. And wait. It takes a really long time. Maybe go take in a movie. Or a movie marathon. Watch all 5 seasons of <a href="http://en.wikipedia.org/wiki/The_wire" title="The Wireon Wikipedia">The Wire</a>. You get the&nbsp;idea&hellip;.</p>
<p><strong>In all&nbsp;practicality&hellip;</strong></p>
<p>Getting this far was relatively simple, given the amount of work that was already done for me by the wonderful <span class="caps">IRE</span> project. The next stage is going to be kind of where the rubber hits the road in terms of usability. I don&rsquo;t really want to have to run through this process on every state more than once so I&rsquo;m thinking I&rsquo;ll probably just serialize the parts I need and store them in an S3 bucket where I can grab it when I need it. But that&rsquo;s a project for&nbsp;later&hellip;</p></div>
<div class="post-metadata alt">
    <p><strong>Tags: </strong>
    <a class="small" href="/tags/Census.html">
        Census
    </a>
    <a class="small" href="/tags/Maps.html">
        Maps
    </a>
    <a class="small" href="/tags/Python.html">
        Python
    </a>
    <a class="small" href="/tags/IRE.html">
        IRE
    </a>
</p>
</div>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'static-eric';
        var disqus_identifier = '2010 Census: A pain in my block';
        var disqus_url = 'http://static-eric.com/2011/11/2010-census-a-pain-in-my-block.html';
        var disqus_developer = 1;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
</article>          </div>
          <footer id="footer">
              Copyright &copy; 2012 Eric van Zanten,  Powered by <a href="http://ringce.com/hyde">hyde</a>.
          </footer>
                  <!-- Javascript at the bottom for fast page loading -->
    <!-- Grab Google CDN's jQuery, with a protocol relative URL; fall back to local if necessary -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.js"></script>
  <script>window.jQuery || document.write('<script src="js/libs/jquery-1.5.1.min.js">\x3C/script>')</script>
  
    

  <!--[if lt IE 7 ]>
    <script src="js/libs/dd_belatedpng.js"></script>
    <script>DD_belatedPNG.fix('img, .png_bg'); // Fix any <img> or .png_bg bg-images. Also, please read goo.gl/mZiyb </script>
  <![endif]-->

      
  </body>
</html>